package com.alg.datastructure;import java.util.Random;/** * @author Yasin Zhang */public class SkipList<T extends Comparable<? super T>> {    private int maxLevel;    private SkipListNode<T>[] root;    private final int[] powers;    private final Random coin = new Random();    public SkipList() {        this(4);    }    public SkipList(int level) {        maxLevel = level;        root = new SkipListNode[maxLevel];        powers = new int[maxLevel];        for (int i = 0; i < maxLevel; i++) {            root[i] = null;        }        choosePowers();    }    public boolean isEmpty() {        return root[0] == null;    }    public void choosePowers() {        powers[maxLevel-1] = (2 << (maxLevel-1)) - 1; // 2^maxLevel - 1        for (int i = maxLevel - 2, j = 0; i >= 0; i--, j++) {            powers[i] = powers[i+1] - (2 << j);  // 2^(j+1)        }    }    public int chooseLevel() {        int i, r = Math.abs(coin.nextInt()) % powers[maxLevel-1] + 1;        for (i = 1; i < maxLevel; i++) {            if (r < powers[i]) {                return i - 1;            }        }        return i - 1;    }    public T search(T key) {        int lvl = maxLevel-1;        SkipListNode<T> prev;        SkipListNode<T> curr;        // find the highest nonnull        while (lvl >= 0 && root[lvl] == null) {            lvl--;        }        prev = curr = root[lvl];        while (true) {            if (key.equals(curr.key)) { // success if equal                return (T) curr.key;            } else if (key.compareTo(curr.key) < 0) { // smaller, go down                if (lvl == 0) {                    return null;                } else if (curr == root[lvl]) {  // no prev, just down                    curr = root[--lvl];                } else {                    curr = prev.next[--lvl];  // prev down                }            } else {                prev = curr;                if (curr.next[lvl] != null) {  // forward on same level                    curr = curr.next[lvl];                } else {  // next is null, then go down                    while (lvl >= 0 && curr.next[lvl] == null) {                        lvl--;                    }                    if (lvl >= 0) {                        curr = curr.next[lvl];                    } else {                        return null;                    }                }            }        }    }    public void insert(T key) {        SkipListNode<T>[] curr = new SkipListNode[maxLevel];        SkipListNode<T>[] prev = new SkipListNode[maxLevel];        SkipListNode<T> newNode;        curr[maxLevel-1] = root[maxLevel-1];        prev[maxLevel-1] = null;        for (int lvl = maxLevel-1; lvl >= 0; lvl--) {            while (curr[lvl] != null && curr[lvl].key.compareTo(key) < 0) {                // if smaller, go to the next                prev[lvl] = curr[lvl];                curr[lvl] = curr[lvl].next[lvl];            }            if (curr[lvl] != null && key.equals(curr[lvl].key)) {                // no duplicate                return;            }            if (lvl > 0) {                if (prev[lvl] == null) {   // still on root                    curr[lvl-1] = root[lvl-1];                    prev[lvl-1] = null;                } else {                    curr[lvl-1] = prev[lvl].next[lvl-1];                    prev[lvl-1] = prev[lvl];                }            }        }        int randomLevel = chooseLevel(); // generate randomly level        newNode = new SkipListNode<>(key, randomLevel + 1);  // generate new node        for (int i = 0; i <= randomLevel; i++) {            newNode.next[i] = curr[i];            if (prev[i] == null) {                root[i] = newNode;            } else {                prev[i].next[i] = newNode;            }        }    }    static class SkipListNode<T> {        T key;        SkipListNode<T>[] next;        SkipListNode(T key, int lvl) {            this.key = key;            this.next = new SkipListNode[lvl];        }    }}